---
title: 'B+Tree'

date: 2024-07-19T14:47:00+08:00

draft: false

summary: "B+树的学习"
categories: [数据结构与算法]
---

<hr>

### 1 前言

还没学习过 B - Tree 的同学可以先看看 [B-Tree](https://xfdzcoder.github.io/home/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/b-tree/)

学习 B+树一方面是为了探索一下B树的变体，另一方面也是为了了解 MySQL 底层存储引擎 InnoDB 的索引结构。下面就步入正题。

B+ 树是 [B 树](https://oi-wiki.org/ds/b-tree/) 的一个升级，它比 B 树更适合实际应用中操作系统的文件索引和数据库索引。

首先介绍一棵 m 阶 B+ 树的特性。![m](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 表示这个树的每一个节点最多可以拥有的子节点个数。一棵 m 阶的 B+ 树和 B 树的差异在于：

1. 有 n 棵子树的节点中含有 n - 1 个关键字（即将区间分为 n 个子区间，每个子区间对应一棵子树）。
2. **所有叶子节点中包含了全部关键字的信息**，及指向含这些关键字记录的指针，**且叶子节点本身依关键字的大小自小而大顺序链接。**
3. **所有的非叶子节点可以看成是索引部分**，节点中**仅含有**其子树（根节点）中的最大（或最小）关键字。
4. 除根节点外，其他所有节点中所含**关键字**的个数最少有  ⌈M/2⌉ 个（向上取整）。（注意：B 树中除根以外的所有非叶子节点至少有  ⌈M/2⌉ 棵子树）。

同时，B+ 树为了方便范围查询，叶子节点之间还用指针串联起来。

### 2 B+ 树相比于 B 树的优势

1. **高度更矮，磁盘寻道次数更少**
   - 由于索引节点上只有索引而没有数据，所以索引节点上能存储比 B 树更多的索引，这样树的高度就会更矮。树的高度越矮，磁盘寻道的次数就会越少。
2. **更容易进行连续访问**
   - 因为数据都集中在叶子节点，而所有叶子节点的高度相同，那么可以在叶子节点中增加前后指针，指向同一个父节点的相邻兄弟节点，这样可以更好地支持查询一个值的前驱或后继，使连续访问更容易实现。比如这样的 SQL 语句：`select * from table_name where t > 10`，如果使用 B+ 树存储数据的话，可以首先定位到数据为 10 的节点，再沿着它的 `next` 指针一路找到所有在该叶子节点右边的叶子节点，返回这些节点包含的数据。而如果使用 B 树结构，由于数据既可以存储在内部节点也可以存储在叶子节点，连续访问的实现会更加繁琐（需要在树的内部结构中进行移动）。

### 3 B+树的操作

操作和 B 树类似，具体过程可参考前文。这里只给出代码仅供参考。

```java

```



